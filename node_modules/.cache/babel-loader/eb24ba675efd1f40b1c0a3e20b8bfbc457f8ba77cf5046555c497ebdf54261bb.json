{"ast":null,"code":"import generateSchedules from \"./generateSchedules\";\nclass Graph {\n  constructor() {\n    this.adjacencyList = new Map();\n  }\n  addNode(node) {\n    this.adjacencyList.set(node, new Set());\n  }\n  addEdge(node1, node2) {\n    this.adjacencyList.get(node1).add(node2);\n    this.adjacencyList.get(node2).add(node1);\n  }\n  getNeighbors(node) {\n    return this.adjacencyList.get(node);\n  }\n  hasEdge(node1, node2) {\n    return this.adjacencyList.get(node1).has(node2);\n  }\n  getNodes() {\n    return new Set(this.adjacencyList.keys());\n  }\n  populateGraph(input) {\n    input.forEach(sec => {\n      this.addNode(sec);\n    });\n    for (let i = 0; i < input.length - 1; i++) {\n      for (let j = i + 1; j < input.length; j++) {\n        if ((input[i].subjectCourse !== input[j].subjectCourse || input[i].scheduleTypeDescription !== input[j].scheduleTypeDescription) && !overlap(input[i], input[j])) {\n          this.addEdge(input[i], input[j]);\n        }\n      }\n    }\n  }\n}\nconst bronKerbosch = (r, p, x, graph, solutions, credits, max_credits) => {\n  if (p.size === 0 && x.size === 0) {\n    solutions.push(r);\n    return;\n  }\n  p.forEach(v => {\n    credits += calcCredits(v);\n    let neighbors = graph.getNeighbors(v);\n    let filtered_neighbors = new Set();\n    if (v.isSectionLinked && v.scheduleTypeDescription !== 'LABORATORIO') neighbors.forEach(sec => {\n      if (sec.subjectCourse === v.subjectCourse && sec.scheduleTypeDescription === 'LABORATORIO' && sec.sequenceNumber.charAt(0) === v.linkIdentifier) filtered_neighbors.add(sec);\n    });else neighbors.forEach(sec => {\n      if (sec.scheduleTypeDescription !== 'LABORATORIO' && calcCredits(sec) + credits <= max_credits) filtered_neighbors.add(sec);\n    });\n    let new_r = union(r, new Set([v]));\n    let new_p = intersection(p, filtered_neighbors);\n    let new_x = intersection(x, filtered_neighbors);\n    bronKerbosch(new_r, new_p, new_x, graph, solutions, credits, max_credits);\n    p.delete(v);\n    x.add(v);\n  });\n};\nfunction union(setA, setB) {\n  const _union = new Set(setA);\n  for (const elem of setB) {\n    _union.add(elem);\n  }\n  return _union;\n}\nfunction intersection(setA, setB) {\n  const _intersection = new Set();\n  for (const elem of setB) {\n    if (setA.has(elem)) {\n      _intersection.add(elem);\n    }\n  }\n  return _intersection;\n}\nconst overlap = (sec1, sec2) => {\n  const days = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"];\n  for (const meetSec1 of sec1.meetingsFaculty) {\n    for (const meetSec2 of sec2.meetingsFaculty) {\n      for (const day of days) {\n        if (meetSec1.meetingTime[day] && meetSec2.meetingTime[day]) {\n          if (meetSec1.meetingTime.beginTime <= meetSec2.meetingTime.endTime && meetSec1.meetingTime.endTime >= meetSec2.meetingTime.beginTime) {\n            return true;\n          }\n          break;\n        }\n      }\n    }\n  }\n  return false;\n};\nconst calcCredits = section => section.scheduleTypeDescription === 'LABORATORIO' ? 0 : section.creditHourHigh + section.creditHourLow;\nconst generateSchedules2 = graph => {\n  let p = graph.getNodes();\n  let solutions = [];\n  let max_credits = 20;\n  bronKerbosch(new Set(), p, new Set(), graph, solutions, 0, max_credits);\n  console.log(solutions);\n  return solutions;\n};","map":{"version":3,"names":["generateSchedules","Graph","constructor","adjacencyList","Map","addNode","node","set","Set","addEdge","node1","node2","get","add","getNeighbors","hasEdge","has","getNodes","keys","populateGraph","input","forEach","sec","i","length","j","subjectCourse","scheduleTypeDescription","overlap","bronKerbosch","r","p","x","graph","solutions","credits","max_credits","size","push","v","calcCredits","neighbors","filtered_neighbors","isSectionLinked","sequenceNumber","charAt","linkIdentifier","new_r","union","new_p","intersection","new_x","delete","setA","setB","_union","elem","_intersection","sec1","sec2","days","meetSec1","meetingsFaculty","meetSec2","day","meetingTime","beginTime","endTime","section","creditHourHigh","creditHourLow","generateSchedules2","console","log"],"sources":["C:/Users/samue/horarios/src/generateSchedules2.js"],"sourcesContent":["import generateSchedules from \"./generateSchedules\";\r\n\r\nclass Graph { \r\n    adjacencyList; \r\n  \r\n    constructor(){ \r\n      this.adjacencyList = new Map(); \r\n    }\r\n  \r\n    addNode(node){ \r\n      this.adjacencyList.set(node, new Set()); \r\n    }\r\n  \r\n    addEdge(node1, node2){ \r\n      this.adjacencyList.get(node1).add(node2); \r\n      this.adjacencyList.get(node2).add(node1); \r\n    }\r\n  \r\n    getNeighbors(node){ \r\n      return this.adjacencyList.get(node); \r\n    }\r\n  \r\n    hasEdge(node1, node2){ \r\n      return this.adjacencyList.get(node1).has(node2); \r\n    }\r\n\r\n    getNodes() {\r\n        return new Set(this.adjacencyList.keys())\r\n    }\r\n\r\n    populateGraph(input) {\r\n\r\n        input.forEach(sec => {\r\n            this.addNode(sec)\r\n        }) \r\n    \r\n        for (let i = 0; i < input.length - 1; i++) {\r\n            for (let j = i + 1; j < input.length; j++) {\r\n                if ((input[i].subjectCourse !== input[j].subjectCourse || \r\n                    input[i].scheduleTypeDescription !== input[j].scheduleTypeDescription) &&\r\n                    !overlap(input[i], input[j])) {\r\n                        this.addEdge(input[i], input[j])\r\n                    }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nconst bronKerbosch = (r, p, x, graph, solutions, credits, max_credits) => {\r\n    if (p.size === 0 && x.size === 0) {\r\n        solutions.push(r)\r\n        return;\r\n    }\r\n    p.forEach(v => {\r\n        credits += calcCredits(v)\r\n        let neighbors = graph.getNeighbors(v)\r\n        let filtered_neighbors = new Set()\r\n        if (v.isSectionLinked && v.scheduleTypeDescription !== 'LABORATORIO')\r\n            neighbors.forEach(sec => {\r\n                if ((sec.subjectCourse === v.subjectCourse) && (sec.scheduleTypeDescription === 'LABORATORIO')\r\n                && (sec.sequenceNumber.charAt(0) === v.linkIdentifier))\r\n                    filtered_neighbors.add(sec)\r\n            })\r\n        else\r\n            neighbors.forEach(sec => {\r\n                if (sec.scheduleTypeDescription !== 'LABORATORIO' && (calcCredits(sec) + credits <= max_credits))\r\n                    filtered_neighbors.add(sec)\r\n            })\r\n        let new_r = union(r, new Set([v]))\r\n        let new_p = intersection(p, filtered_neighbors)\r\n        let new_x = intersection(x, filtered_neighbors)\r\n        bronKerbosch(new_r, new_p, new_x, graph, solutions, credits, max_credits) \r\n        p.delete(v)\r\n        x.add(v)\r\n    })\r\n}\r\n  \r\n  function union(setA, setB) {\r\n    const _union = new Set(setA);\r\n    for (const elem of setB) {\r\n      _union.add(elem);\r\n    }\r\n    return _union;\r\n  }\r\n  \r\n  function intersection(setA, setB) {\r\n    const _intersection = new Set();\r\n    for (const elem of setB) {\r\n      if (setA.has(elem)) {\r\n        _intersection.add(elem);\r\n      }\r\n    }\r\n    return _intersection;\r\n  }\r\n  \r\nconst overlap = (sec1, sec2) => {\r\n    const days = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"];\r\n    for (const meetSec1 of sec1.meetingsFaculty) {\r\n      for (const meetSec2 of sec2.meetingsFaculty) {\r\n        for (const day of days) {\r\n          if (meetSec1.meetingTime[day] && meetSec2.meetingTime[day]) {\r\n            if (meetSec1.meetingTime.beginTime <= meetSec2.meetingTime.endTime\r\n              && meetSec1.meetingTime.endTime >= meetSec2.meetingTime.beginTime) {\r\n                return true\r\n              }\r\n            break  \r\n          }\r\n        }\r\n      }\r\n    }\r\n    return false\r\n}\r\n\r\nconst calcCredits = (section) => (\r\n    section.scheduleTypeDescription === 'LABORATORIO' ? 0 : (section.creditHourHigh + \r\n      section.creditHourLow)\r\n  ) \r\n\r\nconst generateSchedules2 = (graph) => {\r\n    let p = graph.getNodes()\r\n    let solutions = []\r\n    let max_credits = 20\r\n    bronKerbosch(new Set(), p, new Set(), graph, solutions, 0, max_credits)\r\n    console.log(solutions)\r\n    return solutions\r\n}\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}